//https://www.lanqiao.cn/problems/20176/learning/
//@@@
//binary
/*
在一场智力对弈的游戏中，两位玩家小蓝和小桥需要对一个初始值均为 0、大小为 n×n 的矩阵进行操作，以展现他们的智慧和谋略，并确定谁才是最强的策略家。
操作规则如下：
小蓝拥有先手操作权，完成操作后轮到小桥，然后再轮到小蓝，依此规律交替进行。
在小蓝的每个回合中，他可以选择矩阵中的 2 个元素，并将这些元素的值变更为 1。
在小桥的第 1 个回合中，他可以选择一个大小为 1×1 的子矩阵，并将该子矩阵内的所有元素的值重置为 0。在小桥的第 2 个回合中，他可以选择一个 2×2 的子矩阵，并将该子矩阵内的所有元素的值重置为 0。以此类推，在小桥的第 i 个回合中，他可以选择一个大小为 i×i 的子矩阵，并将该子矩阵内所有元素的值重置为 0。
在双方各进行了 n 次操作后，游戏结束。
设在整个游戏过程中，矩阵中值为 1 的元素的数量最多时为 X。
小蓝致力于最大化 X 的值，小桥致力于最小化 X 的值。
假设两位玩家都具有完美的逻辑推理能力，并总是采取最佳策略。请问，X 的值会是多少（即在整个游戏过程中，矩阵中值为 1 的元素的数量最多时是多少）？

解题思路
显然，小桥的每次操作，至少能将矩阵中的一个值为 1 的元素重置为 0，这是无法避免的。因此，为了让矩阵中值为 1 的元素个数尽可能多，小蓝应该尽可能让小桥每次只能重置一个值为 1 的元素。
随着游戏的进行，小桥可以重置的子矩阵大小会越来越大，而小蓝始终只能将 2 个元素的值变更为 1。
对此，我们可以假设从第 i 回合之后，小桥每回合至少可以重置 2 个元素，而在第 i 回合之前（含第 i 回合），小桥每次只能重置 1 个元素。那么在 1 ~ i 回合中，小蓝、小桥每次操作完后矩阵中值为 1 的元素会越来越多（每回合结束后元素个数 +1）。而在 i + 1 ~ n 的回合中，小蓝、小桥每次操作完后矩阵中值为 1 的元素会越来越少。
要使在第 i 回合小桥只能重置 1 个元素，我们需要满足矩阵中任意一个 i×i 的矩阵中至多只有一个值为 1 的元素。这相当于我们要将 n×n 的矩阵尽可能多的切割为若干个 i×i 的子矩阵，然后在每个切割后的子矩阵中（左上角）放置一个元素 1。
在最优的切割手段下，一共可以产生⌈n/i⌉×⌈n/i⌉个子矩阵（当然其中有一部分矩阵的大小并非是 i×i，但在这些矩阵中（左上角），放置一个元素 1 也可以保证不会和其它矩阵的元素 1 同处于一个 i×i 的矩阵）。
因此，在小蓝和小桥的第 i 回合都结束后，矩阵中值为 1 的元素个数最多为 i（每回合 +1），而从第 i + 1 回合开始，每回合结束后矩阵中值为 1 的元素个数最多为⌈n/(i+1)⌉×⌈n/(i+1)⌉−1。
⌈n/i⌉×⌈n/i⌉−1随着 i 的增加会越来越小。
当j≤⌈n/j⌉×⌈n/j⌉−1时（即1≤j≤i时），矩阵中值为 1 的元素的个数元素受 j 影响，我们希望 j 越大越好。
当j>⌈n/j⌉×⌈n/j⌉−1时（即i<j≤n时），矩阵中值为 1 的元素的个数元素受⌈n/j⌉×⌈n/j⌉影响，我们希望 j 越小越好。
由此显然，矩阵中值为 1 的元素个数将在第 i 回合达到峰值。
我们可以将j≤⌈n/j⌉×⌈n/j⌉−1的值设为 1，反之设为 0。那么从第 1 回合到第 n 回合的过程中，j≤⌈n/j⌉×⌈n/j⌉−1的结果将形如：
11111…1000…0
因此，我们可以二分 i 的位置，并计算出答案。
*/
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
typedef long long ll;

void Log(vector<ll>& a){
	ll n=a.size();
	for(ll i=0;i<n;i++){
		cout<<a[i]<<" ";
	}
	cout<<endl;
}

void solve(){
    ll n;
    cin>>n;
    ll l=1,r=n;
    while(l<=r){
        ll m=l+r>>1;

        auto check=[&](ll i)->bool{
            return i<=((n+i-1)/i)*((n+i-1)/i)-1;
        };

        if(check(m)){
            l=m+1;
        }else{
            r=m-1;
        }
    }
    r=max(r,1ll);
    cout<<min(min(r,((n+r-1)/r)*((n+r-1)/r)-1)+2,n*n)<<endl;
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    ll T;
    cin>>T;
    while(T--){
        solve();
    }
    return 0;
}
