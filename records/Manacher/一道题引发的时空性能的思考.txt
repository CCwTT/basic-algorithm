//https://leetcode.cn/problems/check-if-dfs-strings-are-palindromes/submissions/638810029/
//@@@
//manacher
//判断DFS字符串是否回文
typedef long long ll;
class Solution {
public:
    string pre_processor(string s){
        string res="#";
        for(auto c:s){
            res+=c;
            res+='#';
        }
        return res;
    }

    vector<ll> get_p(string s){
        ll n=s.size();
        vector<ll> p(n);
        for(ll i=0,boxm=0,boxr=0;i<n;i++){
            p[i]=i<boxr?min(boxr-i,p[2*boxm-i]):1;
            while(i+p[i]<n&&i-p[i]>=0&&s[i+p[i]]==s[i-p[i]]){
                p[i]++;
            }
            if(i+p[i]>boxr){
                boxr=i+p[i];
                boxm=i;
            }
        }
        return p;
    }

    vector<bool> findAnswer(vector<int>& parent, string s) {
        ll n=parent.size();
        vector<vector<ll>> g(n);
        for(ll i=1;i<n;i++){
            g[parent[i]].push_back(i);
        }
        vector<ll> b(n),e(n);
        string dfs_str;
        ll step=0;
        auto dfs=[&](auto&& dfs,ll p)->void{
            b[p]=step;
            for(auto q:g[p]) if(q!=parent[p]){
                dfs(dfs,q);
            }
            e[p]=step++;
            dfs_str.push_back(s[p]);
        };
        dfs(dfs,0);
        auto pal=get_p(pre_processor(dfs_str));

        auto is_palindrome=[&](ll l,ll r)->bool{
            ll m=l+r+1;
            return pal[m]-1>=r-l+1;
        };
        
        vector<bool> ans(n);
        for(ll i=0;i<n;i++){
            ans[i]=is_palindrome(b[i],e[i]);
        }
        return ans;
    }
};

1、在pre_processor中有3种写法：
写法1：
for(auto c:s){
    res+=c+'#'; //或res+=c+"#";
}
写法2：
for(auto c:s){
    res+=c;
    res+='#';
}
写法三：
for(auto c:s){
    res=res+c+'#';
}
点评：写法1中会先让c和'#'/"#"做加法运算，这显然不符合编码者的语义
写法2是完全正确的
写法3不像写法2直接append，写法3会为中间结果开辟内存空间，O(n^2)会引发内存爆炸

2、1e5的规模，vector<set<ll>> g 比vector<vector<ll>> g 慢600ms 
使用vector<set<ll>> g总时间是1000ms
使用vector<vector<ll>> g总时间是400ms

//https://www.cnblogs.com/Tshaxz/p/18753088
3、递归auto写法比function快50~100倍